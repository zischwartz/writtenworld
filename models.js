// Generated by CoffeeScript 1.3.1
(function() {
  var CellSchema, FeedbackSchema, ObjectId, Rite, RiteSchema, Schema, UserSchema, WorldSchema, events, mongoose, mongooseAuth, ritePropsDefs, slugGenerator, util,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  util = require('util');

  events = require('events');

  mongoose = require('mongoose');

  mongoose.connect('mongodb://localhost/mapist');

  Schema = mongoose.Schema;

  ObjectId = Schema.ObjectId;

  WorldSchema = new Schema({
    owner: ObjectId,
    ownerlogin: {
      type: String
    },
    name: {
      type: String,
      unique: true
    },
    created: {
      type: Date,
      "default": Date.now
    },
    personal: {
      type: Boolean,
      "default": true
    },
    "public": {
      type: Boolean,
      "default": false
    },
    slug: {
      type: String,
      lowercase: true,
      trim: true
    },
    meta: {
      maxZoom: {
        type: Number
      },
      minZoom: {
        type: Number
      },
      defaultChar: {
        type: String,
        "default": ' '
      },
      tileSize: {
        x: {
          type: Number
        },
        y: {
          type: Number
        }
      }
    },
    props: {
      type: Schema.Types.Mixed,
      "default": {}
    }
  });

  slugGenerator = function(options) {
    var key;
    options = options || {};
    key = options.key || 'name';
    return slugGenerator = function(schema) {
      return schema.path(key).set(function(v) {
        this.slug = v.toLowerCase().replace(/[^a-z0-9]/g, '').replace(/-+/g, '');
        return v;
      });
    };
  };

  WorldSchema.plugin(slugGenerator());

  exports.World = mongoose.model('World', WorldSchema);

  exports.World.findOne({
    name: 'main'
  }, function(err, world) {
    var mainWorld;
    if (world) {
      exports.mainWorldId = world._id;
      exports.mainWorld = world;
      return console.log(' Found main world');
    } else {
      console.log(' Could not find main world...');
      mainWorld = new exports.World({
        name: 'main',
        personal: false,
        "public": true,
        meta: {
          maxZoom: 18,
          minZoom: 10,
          tileSize: {
            x: 192,
            y: 256
          }
        },
        props: {
          echoes: true
        }
      });
      return mainWorld.save(function(err, world) {
        if (err) {
          console(log(err));
        }
        console.log(' So we created the main world');
        exports.mainWorldId = world._id;
        return exports.mainWorld;
      });
    }
  });

  ritePropsDefs = {
    echoes: 0,
    echoers: [],
    downroters: []
  };

  RiteSchema = new Schema({
    contents: {
      type: String,
      "default": ' '
    },
    date: {
      type: Date,
      "default": Date.now
    },
    owner: ObjectId,
    props: {
      type: Schema.Types.Mixed,
      "default": {}
    }
  });

  RiteSchema.methods.getOwner = function(cb) {
    return this.db.model('User').findById(this.owner).run(cb);
  };

  Rite = mongoose.model('Rite', RiteSchema);

  CellSchema = new Schema({
    world: ObjectId,
    x: {
      type: Number,
      required: true,
      min: 0
    },
    y: {
      type: Number,
      required: true,
      min: 0
    },
    current: {
      type: Schema.ObjectId,
      ref: 'Rite'
    },
    history: [
      {
        type: Schema.ObjectId,
        ref: 'Rite'
      }
    ]
  });

  CellSchema.index({
    world: 1,
    x: 1,
    y: 1
  }, {
    unique: true
  });

  exports.Cell = mongoose.model('Cell', CellSchema);

  exports.writeCellToDb = function(cellPoint, contents, worldId, riter, isOwnerAuth, isPersonal, props) {
    if (props == null) {
      props = {};
    }
    exports.Cell.findOne({
      world: worldId,
      x: cellPoint.x,
      y: cellPoint.y
    }).populate('current').run(function(err, cell) {
      var cEchoes, doEchoLogic, isAlreadyDownroter, isAlreadyEchoer, isBlank, isBlankRite, isLegitDownrote, isLegitEcho, isOwner, isPotentialEcho, key, originalOwner, rite, val, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      if (err) {
        console.log(err);
      }
      for (key in ritePropsDefs) {
        if (!__hasProp.call(ritePropsDefs, key)) continue;
        val = ritePropsDefs[key];
        if (!(props != null ? props[key] : void 0)) {
          props[key] = val;
        }
      }
      rite = new Rite({
        contents: contents,
        owner: riter,
        props: props
      });
      rite.markModified('props');
      if (!cell) {
        cell = new exports.Cell({
          x: cellPoint.x,
          y: cellPoint.y,
          world: worldId
        });
      }
      if (isPersonal) {
        cell.history.push(rite);
        cell.current = rite;
        rite.save(function(err) {
          cell.current = rite._id;
          return cell.save(function(err) {
            if (err) {
              return console.log(err);
            }
          });
        });
        return;
      }
      isAlreadyEchoer = false;
      isAlreadyDownroter = false;
      if ((cell != null ? (_ref = cell.current) != null ? _ref.props.echoers : void 0 : void 0) && __indexOf.call(cell != null ? (_ref1 = cell.current) != null ? _ref1.props.echoers : void 0 : void 0, riter) >= 0) {
        isAlreadyEchoer = true;
        console.log('ALREADY ECHOER');
      }
      if ((cell != null ? (_ref2 = cell.current) != null ? _ref2.props.downroters : void 0 : void 0) && __indexOf.call(cell != null ? (_ref3 = cell.current) != null ? _ref3.props.downroters : void 0 : void 0, riter) >= 0) {
        isAlreadyDownroter = true;
        console.log('ALREADY DOWNROTER');
      }
      isOwner = riter.toString() === ((_ref4 = cell.current) != null ? _ref4.owner.toString() : void 0);
      isPotentialEcho = ((_ref5 = cell.current) != null ? _ref5.contents : void 0) === rite.contents;
      isLegitEcho = !isOwner && isPotentialEcho && !isAlreadyEchoer;
      isBlank = !cell.current || ((_ref6 = cell.current) != null ? _ref6.contents : void 0) === exports.mainWorld.meta.defaultChar;
      isBlankRite = rite.contents === exports.mainWorld.meta.defaultChar;
      cEchoes = cell != null ? (_ref7 = cell.current) != null ? (_ref8 = _ref7.props) != null ? _ref8.echoes : void 0 : void 0 : void 0;
      isLegitDownrote = false;
      originalOwner = (_ref9 = cell.current) != null ? _ref9.owner : void 0;
      cell.history.push(rite);
      doEchoLogic = function() {
        var eindex;
        if (isBlank && isBlankRite) {
          console.log('blank on blank action');
          return true;
        }
        if (isBlank && !isBlankRite) {
          console.log('WAS CURRENT BLANK, ROTE');
          cell.current = rite;
          rite.save(function(err) {
            cell.current = rite._id;
            return cell.save(function(err) {
              if (err) {
                return console.log(err);
              }
            });
          });
          return true;
        }
        if (isPotentialEcho && isOwner) {
          console.log('echoing yourself too much will make you go blind');
          return true;
        }
        if (isOwner && cEchoes <= 0) {
          console.log('OVERROTE SELF');
          cell.current = rite;
          rite.save(function(err) {
            cell.current = rite._id;
            return cell.save(function(err) {
              if (err) {
                return console.log(err);
              }
            });
          });
          return true;
        }
        if (isOwner && cEchoes > 0) {
          console.log('DOWNVOTED SELF');
          cell.current.props.echoes -= 1;
          cell.current.markModified('props');
          cell.current.save(function(err) {
            if (err) {
              return console.log(err);
            }
          });
          rite.save(function(err) {
            if (err) {
              return console.log(err);
            }
          });
          return true;
        }
        if (isLegitEcho && !isBlankRite && !isAlreadyEchoer) {
          console.log('LEGIT ECHO YO');
          cell.current.props.echoes += 1;
          cell.current.props.echoers.push(riter);
          eindex = cell.current.props.downroters.indexOf(riter);
          cell.current.props.downroters.splice(eindex, 1);
          cell.current.markModified('props');
          cell.current.save(function(err) {
            if (err) {
              return console.log(err);
            }
          });
          rite.save(function(err) {
            if (err) {
              return console.log(err);
            }
          });
          return true;
        }
        if (cEchoes <= 0 && !isOwner && !isAlreadyDownroter) {
          console.log('OVERROTE SOMEONE ELSE');
          cell.current = rite;
          rite.save(function(err) {
            cell.current = rite._id;
            return cell.save(function(err) {
              if (err) {
                return console.log(err);
              }
            });
          });
          return true;
        }
        if (!isOwner && !isPotentialEcho && !isAlreadyDownroter) {
          isLegitDownrote = true;
          console.log('LEGIT DOWNROTE');
          cell.current.props.downroters.push(riter);
          eindex = cell.current.props.echoers.indexOf(riter);
          cell.current.props.echoers.splice(eindex, 1);
          cell.current.props.echoes -= 1;
          cell.current.markModified('props');
          cell.current.save(function(err) {
            if (err) {
              return console.log(err);
            }
          });
          rite.save(function(err) {
            if (err) {
              return console.log(err);
            }
          });
          return true;
        }
      };
      doEchoLogic();
      if (isLegitEcho) {
        console.log('ADDING AN ECHO TO THAT USER if it exists yo');
        exports.User.findById(riter, function(err, user) {
          if (user) {
            user.totalRites += 1;
            return user.save(function(err) {
              if (err) {
                return console.log(err);
              }
            });
          }
        });
      }
      if (isLegitEcho || isLegitDownrote || (cEchoes <= 0 && !isOwner)) {
        return exports.User.findById(originalOwner, function(err, user) {
          console.log('trying to send a message');
          if (isLegitEcho && user) {
            console.log('SENDING echo msg congrats');
            user.totalEchoes += 1;
            user.save(function(err) {
              if (err) {
                return console.log(err);
              }
            });
            return user.emit('receivedEcho', rite);
          } else if (user && !isAlreadyDownroter) {
            console.log('SENDING overrite msg boo');
            return user.emit('receivedOverRite', rite);
          }
        });
      }
    });
    return true;
  };

  mongooseAuth = require('mongoose-auth');

  UserSchema = new Schema({
    totalRites: {
      type: Number,
      "default": 0
    },
    activeRites: {
      type: Number,
      "default": 0
    },
    totalEchoes: {
      type: Number,
      "default": 0
    },
    color: {
      type: String,
      "default": ''
    },
    personalWorld: ObjectId,
    email: String
  });

  UserSchema.plugin(mongooseAuth, {
    everymodule: {
      everyauth: {
        User: function() {
          return exports.User;
        }
      }
    },
    password: {
      extraParams: {
        email: String
      },
      everyauth: {
        getLoginPath: '/login',
        postLoginPath: '/login',
        loginView: 'login.jade',
        getRegisterPath: '/register',
        postRegisterPath: '/register',
        registerView: 'register.jade',
        loginSuccessRedirect: '/',
        registerSuccessRedirect: '/',
        respondToRegistrationSucceed: function(res, user, data) {
          var personal;
          personal = new exports.World({
            personal: true,
            owner: user._id,
            name: "" + user.login + "'s History",
            ownerlogin: user.login
          });
          personal.save(function(err, doc) {
            user.personalWorld = personal._id;
            return user.save(function(err) {
              if (err) {
                return console.log(err);
              }
            });
          });
          if (data.session.redirectTo) {
            res.writeHead(303, {
              'Location': data.session.redirectTo
            });
          } else {
            res.writeHead(303, {
              'Location': '/'
            });
          }
          res.end();
          return true;
        }
      }
    }
  });

  exports.User = mongoose.model('User', UserSchema);

  FeedbackSchema = new Schema({
    contents: {
      type: String,
      "default": ' '
    }
  });

  exports.Feedback = mongoose.model('Feedback', FeedbackSchema);

  exports.mongooseAuth = mongooseAuth;

}).call(this);
